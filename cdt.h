//
// Created by rainbowwing on 2023/8/25.
//

#ifndef THICKEN2_CDT_H
#define THICKEN2_CDT_H

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Constrained_Delaunay_triangulation_2.h>
#include <CGAL/Polygon_2.h>
#include <vector>
#include <CGAL/Arrangement_2.h>
#include <CGAL/Arr_segment_traits_2.h>
#include <CGAL/Fuzzy_iso_box.h>
typedef CGAL::Arr_segment_traits_2<K2> Traits_2;
typedef CGAL::Arrangement_2<Traits_2> Arrangement_2;

typedef CGAL::Constrained_Delaunay_triangulation_2<K2> CDT;
typedef CGAL::Polygon_2<K2> Polygon_2;


typedef CGAL::Exact_predicates_inexact_constructions_kernel K;

typedef K::Point_3 Point;
typedef CGAL::Search_traits_3<K> STraits;
typedef CGAL::Fuzzy_sphere<STraits> Fuzzy_circle;
typedef CGAL::Kd_tree<STraits> Kd_tree;

typedef CGAL::Search_traits_3<K2> STraitsK2;
typedef CGAL::Fuzzy_sphere<STraitsK2> Fuzzy_circle_K2;
typedef CGAL::Kd_tree<STraitsK2> Kd_tree_K2;
typedef CGAL::Fuzzy_iso_box<STraitsK2> FuzzyBoxK2;

typedef CGAL::Delaunay_triangulation_3<K> Delaunay3D;
typedef CGAL::Delaunay_triangulation_3<K2> Delaunay3D_K2;

typedef CGAL::Constrained_Delaunay_triangulation_2<K2> CDT;




vector<vector<K2::Point_3> > CGAL_CDT(vector<K2::Point_3> sorted_bound_vertex, vector<K2::Segment_3> cs,K2::Triangle_3 origin_face) {

    //CGAL::make_conforming_Delaunay_2();
    // cout << sorted_bound_vertex.size() <<" "<< cs.size() << endl;
    K2::Point_3 base_point_3d = origin_face.vertex(0);


    K2::Vector_3 origin_face_v0 = origin_face.vertex(1) - origin_face.vertex(0);
    K2::Vector_3 origin_face_v1 = origin_face.vertex(2) - origin_face.vertex(0);
    K2::Vector_3 new_direct = CGAL::cross_product(origin_face_v0,origin_face_v1);
    new_direct = new_direct /  CGAL::Epeck::FT(Point_K2_to_iGameVertex(K2::Point_3(0,0,0) +  new_direct).norm());
    K2::Vector_3 X_axis = origin_face_v0 / CGAL::Epeck::FT(Point_K2_to_iGameVertex(K2::Point_3(0,0,0) + origin_face_v0).norm());
    K2::Vector_3 Y_axis = CGAL::cross_product(new_direct,X_axis);


    vector<CDT::Vertex_handle> sorted_bound_vertex_in_cdt(sorted_bound_vertex.size());


    CDT cdt;
    map<CDT::Vertex_handle,K2::Point_3> mp;
    for(int i=0;i<sorted_bound_vertex.size();i++){
        CGAL::Epeck::FT x = (sorted_bound_vertex[i]-base_point_3d) * X_axis;
        CGAL::Epeck::FT y = (sorted_bound_vertex[i]-base_point_3d) * Y_axis;
        auto t = Point_K2_to_iGameVertex(sorted_bound_vertex[i]);
        // cout <<"X Y : " <<CGAL::to_double(x) <<" "<<CGAL::to_double(y) << endl;
        //cout <<"t: "<< t.x() <<" "<<t.y()<<" "<<t.z() << endl;
        auto tt = base_point_3d + x*X_axis + y*Y_axis;
        //  cout <<"tt: "<< tt.x() <<" "<<tt.y()<<" "<<tt.z() << endl;

        sorted_bound_vertex_in_cdt[i] = cdt.insert(K2::Point_2(x,y));
        mp[ sorted_bound_vertex_in_cdt[i] ] = sorted_bound_vertex[i];
    }


    CGAL::Polygon_2<K2>poly;

    for(int i=0;i<sorted_bound_vertex.size();i++){
        poly.push_back(cdt.point(sorted_bound_vertex_in_cdt[i]));
    }

    CGAL::make_conforming_Gabriel_2(cdt);


    vector<vector<K2::Point_2> > faces;
    for(auto fit = cdt.finite_faces_begin();fit != cdt.finite_faces_end();fit++){
        faces.push_back({cdt.point(fit->vertex(0)),cdt.point(fit->vertex(1)),cdt.point(fit->vertex(2))});
    }
    for(K2::Segment_3 seg: cs){ // 这里是人工的带约束cdt，自己通过计算求交，感觉这里可以加速
        vector<vector<K2::Point_2> > faces_new;
        CGAL::Epeck::FT x0 = (seg.vertex(0) - base_point_3d) * X_axis;
        CGAL::Epeck::FT y0 = (seg.vertex(0) - base_point_3d) * Y_axis;
        CGAL::Epeck::FT x1 = (seg.vertex(1) - base_point_3d) * X_axis;
        CGAL::Epeck::FT y1 = (seg.vertex(1) - base_point_3d) * Y_axis;

        K2::Segment_2 seg2(K2::Point_2(x0,y0),K2::Point_2(x1,y1));

        for(auto face : faces){
            K2::Triangle_2 tri(face[0],face[1],face[2]);
            CGAL::cpp11::result_of<K2::Intersect_2(K2::Segment_2 , K2::Triangle_2)>::type
                    res_st = intersection(seg2,tri);

            if (res_st) {
                if (const K2::Segment_2 *s = boost::get<K2::Segment_2>(&*res_st)) {
                    bool is_same_edge = false;
                    for(int i=0;i<3;i++){
                        K2::Segment_2 edge(face[i],face[(i+1)%3]);
                        if(segment_in_line(edge,*s))
                            is_same_edge = true;
                    }
                    if(!is_same_edge){
                        CGAL::cpp11::result_of<K2::Intersect_2(K2::Line_2 , K2::Triangle_2)>::type
                                res_lt = intersection(seg2.supporting_line(),tri);
                        if (const K2::Segment_2 *ss = boost::get<K2::Segment_2>(&*res_lt)) {
                            K2::Point_2 v0 = ss->vertex(0);
                            K2::Point_2 v1 = ss->vertex(1);

                            vector <K2::Point_2> positive_side;
                            vector <K2::Point_2> negative_side;
                            for (int i = 0; i < 3; i++) {
                                if (seg2.supporting_line().has_on_positive_side(face[i])) {
                                    positive_side.push_back(face[i]);
                                } else if (seg2.supporting_line().has_on_negative_side(face[i])) {
                                    negative_side.push_back(face[i]);
                                }
                            }
                            for (vector <K2::Point_2> vs: {positive_side, negative_side}) {
                                if (vs.size() == 1) {
                                    faces_new.push_back({v0,v1,vs[0]});
                                } else if (vs.size() == 2) {
                                    vector<K2::Point_2> ans0v0;
                                    vector<K2::Point_2> ans0v1;
                                    vector<K2::Point_2> ans1v0;
                                    vector<K2::Point_2> ans1v1;
                                    K2::Segment_2 v0s0(v0,vs[0]);
                                    K2::Segment_2 v1s1(v1,vs[1]);
                                    CGAL::cpp11::result_of<K2::Intersect_2(K2::Segment_2 , K2::Segment_2)>::type
                                            res_ss2 = intersection(v0s0,v1s1);
                                    if(!res_ss2){
                                        ans0v0 = {v0,vs[0],v1};
                                        ans1v0 = {v0,v1,vs[1]};
                                    }
                                    else{
                                        ans0v0 = {v0,vs[1],v1};
                                        ans1v0 = {v0,v1,vs[0]};
                                    }
                                    ans0v1 = {vs[0],vs[1],v1};
                                    ans1v1 = {vs[0],vs[1],v0};
                                    if(triangle_squared_aspect_ratio(ans0v0) + triangle_squared_aspect_ratio(ans0v1) <
                                       triangle_squared_aspect_ratio(ans1v0) + triangle_squared_aspect_ratio(ans1v1)
                                            ){
                                        faces_new.push_back(ans0v0);
                                        faces_new.push_back(ans0v1);
                                    }
                                    else{
                                        faces_new.push_back(ans1v0);
                                        faces_new.push_back(ans1v1);
                                    }

                                }

                            }
                            continue;
                        }
                    }
                }
            }
            faces_new.push_back(face);
        }
        swap(faces_new,faces);
    }

    vector<vector<K2::Point_3> > ret;
    K2::Vector_3 vec = cross_product(origin_face.vertex(1)-origin_face.vertex(0),
                                     origin_face.vertex(2)-origin_face.vertex(0)
    );
//    for(auto i : faces){
//        vector<K2::Point_3>tmp(3);
//        for(int j=0;j<3;j++){
//            tmp[j] = base_point_3d + i[j].x()*X_axis + i[j].y()*Y_axis;
//        }
//这里加kd树
//        vector<K2::Point_3>remapping(3);
//
//        K2::Vector_3 vec1 = cross_product(remapping[1] - remapping[0],remapping[2] - remapping[0]);
//        if(vec * vec1 < CGAL::Epeck::FT(0))
//            swap(remapping[1],remapping[2]);
//
//        ret.push_back(remapping);
//    }

    return ret;
}


vector<vector<K2::Point_3> > CGAL_CDT_NEW(vector<K2::Point_3> sorted_bound_vertex, vector<K2::Segment_3> cs,K2::Triangle_3 origin_face) {

    //CGAL::make_conforming_Delaunay_2();
    // cout << sorted_bound_vertex.size() <<" "<< cs.size() << endl;
    K2::Point_3 base_point_3d = origin_face.vertex(0);
    CDT cdt;

    K2::Vector_3 origin_face_v0 = origin_face.vertex(1) - origin_face.vertex(0);
    K2::Vector_3 origin_face_v1 = origin_face.vertex(2) - origin_face.vertex(0);
    K2::Vector_3 new_direct = CGAL::cross_product(origin_face_v0,origin_face_v1);
    new_direct = new_direct /  CGAL::Epeck::FT(Point_K2_to_iGameVertex(K2::Point_3(0,0,0) +  new_direct).norm());
    K2::Vector_3 X_axis = origin_face_v0 / CGAL::Epeck::FT(Point_K2_to_iGameVertex(K2::Point_3(0,0,0) + origin_face_v0).norm());
    K2::Vector_3 Y_axis = CGAL::cross_product(new_direct,X_axis);

    std::vector<K2::Point_2> polygon_vertices;
    Arrangement_2 arrangement;
    for(int i=0;i<sorted_bound_vertex.size();i++){
        CGAL::Epeck::FT x = (sorted_bound_vertex[i]-base_point_3d) * X_axis;
        CGAL::Epeck::FT y = (sorted_bound_vertex[i]-base_point_3d) * Y_axis;
        //CGAL::insert(arrangement,K2::Point_2(x,y));
        cdt.insert(K2::Point_2(x,y));
        polygon_vertices.emplace_back(x,y);
    }

    Polygon_2 polygon(polygon_vertices.begin(), polygon_vertices.end());

    std::vector<K2::Point_2> bounded_polygon_vertices;
    for(int i=0;i<3;i++){
        CGAL::Epeck::FT x = (origin_face.vertex(i)-base_point_3d) * X_axis;
        CGAL::Epeck::FT y = (origin_face.vertex(i)-base_point_3d) * Y_axis;
        bounded_polygon_vertices.emplace_back(x,y);
    }
    Polygon_2 bounded_polygon(bounded_polygon_vertices.begin(),bounded_polygon_vertices.end());


    for(int i=0;i<3;i++){
        CGAL::Epeck::FT x0 = (origin_face.vertex(i)-base_point_3d) * X_axis;
        CGAL::Epeck::FT y0 = (origin_face.vertex(i)-base_point_3d) * Y_axis;
        CGAL::Epeck::FT x1 = (origin_face.vertex((i+1)%3)-base_point_3d) * X_axis;
        CGAL::Epeck::FT y1 = (origin_face.vertex((i+1)%3)-base_point_3d) * Y_axis;
        K2::Segment_2 seg(K2::Point_2(x0,y0) ,K2::Point_2(x1,y1));
        CGAL::insert(arrangement,seg);
        //cdt.insert_constraint(K2::Point_2(x0,y0) ,K2::Point_2(x1,y1));
    }
    for(auto s: cs){
        CGAL::Epeck::FT x0 = (s.vertex(0)-base_point_3d) * X_axis;
        CGAL::Epeck::FT y0 = (s.vertex(0)-base_point_3d) * Y_axis;
        CGAL::Epeck::FT x1 = (s.vertex(1)-base_point_3d) * X_axis;
        CGAL::Epeck::FT y1 = (s.vertex(1)-base_point_3d) * Y_axis;
        K2::Segment_2 seg(K2::Point_2(x0,y0) ,K2::Point_2(x1,y1));
        CGAL::insert(arrangement,seg);
        //cdt.insert_constraint(K2::Point_2(x0,y0) ,K2::Point_2(x1,y1));
    }
    for (auto eit = arrangement.edges_begin(); eit != arrangement.edges_end(); ++eit) {
        K2::Segment_2 seg = eit->curve();
        K2::Point_2 source = seg.source();
        K2::Point_2 target = seg.target();
        cdt.insert_constraint(source,target);
//        std::cout << "Segment: ((" << source.x() << ", " << source.y() << "), ("
//                  << target.x() << ", " << target.y() << "))\n";
    }


    K2::Vector_3 vec = cross_product(origin_face.vertex(1)-origin_face.vertex(0),
                                     origin_face.vertex(2)-origin_face.vertex(0)
    );

    vector<vector<K2::Point_3> > ret;
    for (CDT::Finite_faces_iterator fit = cdt.finite_faces_begin(); fit != cdt.finite_faces_end(); ++fit) {
        K2::Triangle_2 t = cdt.triangle(fit);
        if(bounded_polygon.has_on_bounded_side(CGAL::centroid(t))) {
            vector<K2::Point_3>tmp(3);
            for(int j=0;j<3;j++){
                tmp[j] = base_point_3d + t[j].x()*X_axis + t[j].y()*Y_axis;
            }
            K2::Vector_3 vec1 = cross_product(tmp[1] - tmp[0],tmp[2] - tmp[0]);
            if(vec * vec1 < CGAL::Epeck::FT(0))
                swap(tmp[1],tmp[2]);

            ret.push_back(tmp);
        }
    }


    return ret;
}

#endif //THICKEN2_CDT_H
